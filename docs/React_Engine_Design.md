# 🧠 React Engine 설계도

> **작성일**: 2025년 9월 13일  
> **상태**: 설계 완료 → 단계적 개발 준비  
> **목표**: 새로운 접근법으로 React Engine 재설계 (MVP → 점진적 확장)

---

## 📋 설계 개요

### 현재 상황
- ✅ AI Brain (Google Gemini API) 연동 완료
- ✅ Tool Manager 시스템 구축 완료  
- ✅ File Tool 구현 완료
- 🔄 React Engine 재설계 필요

### 설계 목표
- [x] 사용자 목표를 단계별로 실행
- [x] 명확한 사고 → 행동 → 관찰 패턴
- [x] 복잡성 관리 및 무한루프 방지
- [x] 도구들 간의 효율적 연계
- [x] **단계적 개발**: MVP부터 점진적 확장으로 안정성 확보

---

## 🎯 핵심 설계 질문들

### 1. 엔진의 주요 목적
- [x] **선택됨**: 계획 기반 순차 실행 + 단계별 검증
- [ ] 옵션 B: 반복적 사고 과정
- [ ] 옵션 C: 상태 기반 머신

### 2. 실행 구조
```
사용자 목표 입력
    ↓
🧠 계획 수립 (Goal → Detailed Steps)
    ↓
📋 계획 검토 및 승인
    ↓
🔄 순차 실행 루프:
   ├─ 현재 단계 실행
   ├─ 결과 검증
   ├─ 성공시: 다음 단계로
   └─ 실패시: 계획 수정 또는 재시도
    ↓
✅ 최종 목표 달성 확인
```

### 3. 복잡성 제어 방법
- [x] 단계별 검증 및 수정
- [x] 최대 실행 횟수 제한 (안전장치)
- [x] ⏰ **시간 제한** (전체 실행 시간 상한선)
- [x] 🧠 **실행 결과 학습** (실패 패턴 기록 및 개선)
- [x] 📊 **부분 성공 인정** (일정 비율 이상 성공시 전체 성공 처리)
- [x] 💬 **컨텍스트 이해 강화** (대명사, 시간 정보 활용)
- [x] 🔄 **롤백 기능** (실수 시 이전 상태 복원)
- [ ] 사용자 개입 지점 제공

---

## 🚀 단계적 개발 전략

> **핵심 철학**: "MVP → 점진적 확장"  
> **목표**: 장기적인 유지보수성과 안정성 확보

### 📦 1단계: 핵심 MVP (1주차)
**목표**: 기본 동작 확인 가능한 최소 구성

#### 구현 대상 (3개만!)
- **GoalExecutor**: 메인 엔진 (계획 수립 + 실행 관리)
- **StepExecutor**: 단계별 실행기 (도구 호출 + 결과 검증)  

#### 왜 이것만?
- ✅ 기본 동작 확인 가능
- ✅ 테스트하면서 문제점 파악
- ✅ 나머지 기능은 GoalExecutor 안에 간단히 구현
- ✅ 빠른 프로토타입 완성으로 피드백 수집

### 📦 2단계: 필수 기능 분리 (2주차)
**목표**: 코드 복잡성 관리 및 역할 분리

#### 추가 구현
- **+ PlanManager**: GoalExecutor에서 계획 관리 기능 분리
- **+ ProgressReporter**: 사용자 피드백 시스템 개선

#### 왜 이 시점에?
- ✅ 코드가 복잡해지기 시작하는 시점
- ✅ 단일 책임 원칙 적용 필요
- ✅ 테스트 및 디버깅 용이성 향상

### 📦 3단계: 안정성 강화 (3주차)
**목표**: 실무 사용 가능한 안정성 확보

#### 추가 구현
- **+ RollbackManager**: 실수 복원 시스템
- **+ SuccessEvaluator**: 부분 성공 처리 로직

#### 왜 이 시점에?
- ✅ 기본 기능이 안정화된 후 안전장치 강화
- ✅ 실제 사용 시나리오에서 필요한 기능들
- ✅ 사용자 신뢰도 향상

### 📦 4단계: 지능화 (4주차+)
**목표**: 사용자 경험 극대화 및 학습 기능

#### 추가 구현
- **+ ContextManager**: 대화 연속성 및 컨텍스트 이해
- **+ LearningManager**: 실행 결과 학습 및 최적화

#### 왜 마지막에?
- ✅ 복잡한 AI 기능은 기반이 안정된 후 추가
- ✅ 사용 데이터 누적 후 학습 효과 극대화
- ✅ 고급 기능으로 차별화 포인트 확보

### 🎯 각 단계별 성공 기준
- **1단계**: 기본 시나리오 1개 완전 동작
- **2단계**: 복잡한 시나리오 처리 가능
- **3단계**: 실패 상황 우아하게 처리
- **4단계**: 지능적이고 학습하는 AI 어시스턴트

---

## 🏗️ 컴포넌트 설계

### 핵심 구성 요소

#### 1. **GoalExecutor** (메인 엔진)
- 목표 받기 → 도구 목록 확인 → 계획 수립 → 실행 → 결과 반환
- 사용자에게 간단한 진행 상황 표시

#### 2. **PlanManager** (계획 관리자)  
- 초기 계획 수립
- 실패시 계획 수정/재수립 결정
- 계획 검증 및 실행 가능성 확인

#### 3. **StepExecutor** (단계 실행기)
- 개별 계획 단계 실행
- 도구 호출 및 결과 검증
- 실패시 에러 정보를 PlanManager에 전달

#### 4. **ProgressReporter** (진행 상황 보고)
- 사용자에게 현재 작업 상황을 한 줄로 표시
- "~하는 중..." 형태의 친근한 메시지

#### 6. **LearningManager** (학습 관리자) 🆕
- 도구 사용 결과 및 실패 패턴 학습
- 자주 실패하는 방법/경로 기록
- 다음 계획 수립 시 학습된 정보 반영
- 성공률 높은 방법 우선 추천

#### 7. **SuccessEvaluator** (성공 평가자) 🆕  
- 부분 성공 인정 기준 설정
- 성공률 기반 결과 판정 (예: 80% 이상 성공시 전체 성공)
- 세부 성공/실패 현황 리포트
- 사용자에게 명확한 결과 설명

#### 8. **ContextManager** (컨텍스트 관리자) 🆕
- 이전 대화 기록 참조 ("그 폴더", "어제 만든 파일" 등)
- 시간 정보 활용한 검색 및 필터링
- 대명사 및 지시어 해석 강화
- 대화 흐름 연속성 유지

#### 9. **RollbackManager** (롤백 관리자) 🆕
- 실행 전 상태 스냅샷 생성
- 작업 실패 시 이전 상태로 복원
- 부분 실행 취소 기능
- 사용자 요청 시 수동 롤백 지원

---

## 💭 설계 논의 내용

### 🎯 사용자 시나리오 분석
**목표**: "바탕화면에 폴더 새로 만들고, 바탕화면 논문 폴더에서 젠트리피케이션 관련 논문만 찾아서 이동시켜줘"

**AI의 계획 수립**:
1. 바탕화면 절대 경로 찾기
2. 바탕화면에 새 폴더 만들기  
3. 바탕화면에 있는 파일/폴더들 조회하기
4. 사용자가 말하는 논문폴더에 가장 부합해보이는 폴더 찾기
5. 그 폴더에 들어있는 파일/폴더들 조회하기
6. 젠트리피케이션 관련 논문 파일 추리기
7. 이동하기
8. 최종 점검 후 최종목표 달성 여부 확인하기

**핵심 특징**:
- 📋 **명확한 계획 수립**: 목표를 구체적인 단계들로 분해
- 🔄 **순차적 실행**: 계획된 단계를 하나씩 순서대로 진행
- ✅ **단계별 검증**: 각 단계 완료 후 성공/실패 판단
- 🔧 **동적 수정**: 필요시 계획 조정 및 수정
- 🎯 **최종 확인**: 전체 목표 달성 여부 검증
- 💬 **컨텍스트 활용**: "그 폴더" → 이전 대화에서 언급된 폴더 자동 인식
- 🔄 **안전한 실행**: 실수 시 롤백으로 원상 복구

### 🏗️ 설계 방향 결정
**선택된 접근법**: **계획 기반 순차 실행 엔진**
- 도구 인식 → 계획 수립 → 순차 실행 → 에러시 LLM 재량 판단

### 🔄 실행 플로우
```
사용자 목표 입력
    ↓
� **컨텍스트 분석** ("그 폴더", "어제 파일" 등 해석)
    ↓
�🔧 사용 가능한 도구 목록 확인
    ↓  
🧠 목표 분석 및 계획 수립 ("계획을 수립하는 중...")
    ↓
📋 계획 검토 및 검증
    ↓
📸 **실행 전 상태 스냅샷 생성** (롤백 준비)
    ↓
🔄 순차 실행 루프:
   ├─ 📢 진행 상황 표시 ("~을 확인하는 중...")
   ├─ 🛠️ 도구 실행
   ├─ ✅ 결과 검증 
   ├─ 📊 **부분 성공 평가** (예: 10개 중 8개 성공 → 80% 성공률)
   ├─ 🧠 **학습 데이터 기록** (성공/실패 패턴, 실행 시간 등)
   ├─ 성공시: 다음 단계로
   └─ 실패시: 🧠 LLM 판단
       ├─ 📚 **학습된 정보 참조** (이전 실패 방법 회피)
       ├─ 파라미터 수정 후 재시도
       └─ 계획 수정/재수립
   ├─ ⏰ **시간/횟수 제한 체크**
   └─ ❌ **실패시 롤백 옵션 제공**
    ↓
🎯 최종 목표 달성 확인 및 **상세 결과 보고**
```

#### 1. **실패 처리 전략**
- ✅ **LLM 재량 판단**: 도구 에러 발생시 LLM이 상황을 분석하여 결정
  - 옵션 A: 도구 파라미터/사용법 수정하여 재시도
  - 옵션 B: 계획 전체 또는 일부 재수립
  - 상황에 따라 LLM이 최적의 방법 선택

#### 2. **계획 세부 수준**
- ✅ **도구 기반 계획**: AI가 보유한 도구 목록을 먼저 파악 후 계획 수립
- ✅ **적정 추상화**: 너무 세분화하지 않고 도구 단위로 계획 구성

#### 3. **사용자 피드백**
- ✅ **간단한 진행 상황**: 한 줄 정도의 현재 작업 표시
  - "계획을 수립하는 중..."
  - "바탕화면 파일 목록을 확인하는 중..."  
  - "논문 폴더를 확인하는 중..."
  - "젠트리피케이션 관련 파일을 찾는 중..."

#### 4. **AI 작동 방식**
- ✅ **도구 목록 확인** → **목표 분석** → **계획 수립** → **순차 실행**
- ✅ **에러 발생시 상황별 대응**: 파라미터 수정 vs 계획 재수립
- ✅ **학습 기반 개선**: 이전 실패 경험을 통한 방법 최적화
- ✅ **시간/횟수 관리**: 효율적 실행을 위한 제한 설정
- ✅ **유연한 성공 기준**: 부분 성공도 인정하는 실용적 접근
- ✅ **컨텍스트 연속성**: 이전 대화 내용 참조한 지능적 해석
- ✅ **안전한 실행**: 롤백 기능으로 실수 시 복원 가능

### ✅ LLM 계획 안정화 전략
- 계획 생성 프롬프트는 반드시 JSON 배열 형태로 응답하도록 강제합니다.
- 응답을 `PlanStep` 데이터 클래스로 파싱하고, 각 Step마다 `status`(todo/in_progress/done)를 저장합니다.
- GoalExecutor는 Thinking 단계마다 이 Step 리스트를 LLM에 함께 넘겨 현재 단계와 완료 여부를 확인합니다.
- JSON 파싱이 실패하면 즉시 계획 재생성을 요청하고, 실패 원인을 로그로 남깁니다.

### ✅ 실패 및 재시도 관리
- `StepResult`에는 `status`, `error_reason`, `attempt`를 포함하여 재시도 여부를 판단합니다.
- 스텝별 `max_attempts`를 두고 초과 시 전체 계획 재검토로 전환합니다.
- 실패 시 최근 커맨드, 파라미터, 오류 메시지를 세션 단기 기억(`ExecutionContext`)에 저장하고 다음 Thinking 프롬프트에 제공하여 같은 실수를 반복하지 않도록 합니다.
- 재시도가 아니라 계획 자체가 잘못된 경우, 해당 이유와 함께 GoalExecutor가 LLM에게 계획 재구성을 요청합니다.

### ✅ 상태 및 기억 관리
- 세션 전용 `ExecutionContext` 데이터 클래스를 도입하여 목표, 계획, 현재 단계, 도구 결과, 실패 로그를 한곳에 모읍니다.
- 롤백, 학습, 진행 보고 등 다른 컴포넌트는 Context만 참조하고 직접 파일/DB에 접근하지 않습니다.
- 실패 로그와 스텝 진행 상황을 Context에 기록하고, Thinking 프롬프트에 요약하여 단기 기억처럼 활용합니다.

### ✅ 테스트 전략 메모
- 자동 스모크 테스트는 최소한의 가짜 환경으로 엔진 뼈대만 확인하고, 실제 LLM 연동 검증은 별도의 수동/통합 시나리오로 진행합니다.

### ✅ 데이터 객체 규약
- `PlanStep`, `StepResult`, `ExecutionContext` 등 공통 DTO(Data Transfer Object)를 정의해 컴포넌트 간 데이터 교환을 일관되게 유지합니다.
- `StepCompletedEvent`, `PlanUpdatedEvent` 같은 이벤트 객체로 주요 상태 변화를 기록하면, 로깅/학습/모니터링 모듈이 동일한 포맷을 사용할 수 있습니다.

### 🔍 새로운 기능 상세 설명

#### 💬 컨텍스트 이해 강화 시스템
- **대명사 해석**: "그 폴더", "이 파일", "방금 만든" 등의 지시어 처리
- **시간 기반 검색**: "어제 만든 파일", "지난주 폴더", "최근 문서" 등
- **대화 기록 참조**: 이전 대화에서 언급된 경로나 파일명 추적
- **상황 맥락 파악**: 현재 작업 중인 프로젝트나 폴더 상황 인지

#### 🔄 롤백 관리 시스템  
- **스냅샷 생성**: 실행 전 파일/폴더 상태 기록
- **선택적 롤백**: 특정 단계만 되돌리기 가능
- **자동 롤백**: 심각한 에러 발생시 자동 복원
- **수동 롤백**: 사용자 요청시 언제든 이전 상태로 복원
- **롤백 히스토리**: 여러 단계 이전 상태까지 복원 가능

#### 📚 실행 결과 학습 시스템
- **실패 패턴 기록**: 특정 도구 + 파라미터 조합의 실패율 추적
- **성공 방법 우선순위**: 과거 성공률이 높은 방법을 먼저 시도
- **경로 최적화**: 자주 실패하는 파일 경로나 접근 방식 회피
- **학습 데이터 저장**: JSON 형태로 로컬에 누적 저장

#### ⏰ 시간 제한 시스템
- **전체 실행 시간 제한**: 과도하게 긴 작업 방지
- **단계별 시간 측정**: 각 단계의 소요 시간 기록
- **시간 초과시 처리**: 우아한 종료 및 부분 결과 보고

#### 📊 부분 성공 평가 시스템
- **성공률 기준**: 기본 80% 이상 성공시 전체 성공으로 처리
- **상세 리포트**: "10개 파일 중 8개 성공적으로 이동" 형태의 명확한 보고
- **실패 항목 명시**: 실패한 구체적 항목과 이유 제공
